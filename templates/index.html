<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Chat Saude v1.0.0</title>
  <a href="{{ url_for('logout') }}" class="logout-btn">Logout</a>
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css"/>
  <script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>

  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>

  <div class="chat-container">
    <div id="messages" class="messages">
      <div class="message bot">
        <span>Ola! Para consultas detalhadas, insira um ID de paciente e sua pergunta. Para listar pacientes, use os filtros abaixo ou digite sua busca em linguagem natural.</span>
      </div>
    </div>

    <div class="filter-container">
        <input type="number" id="idadeMin" placeholder="Idade Minima" />
        <input type="number" id="idadeMax" placeholder="Idade Maxima" />
        
        <select id="convenioFilter" multiple>
        </select>
        
        <select id="profissionalFilter" multiple>
        </select>

        <select id="conjuntoFilter" multiple>
        </select>

        <button id="filterBtn">Filtrar Pacientes</button>
    </div>
    <hr>

    <div class="input-container" style="flex-direction: column;">
      <input type="text" id="patientId" placeholder="ID do Paciente (para consultas com IA)" style="margin-bottom: 8px; padding: 0.5rem; border: 1px solid var(--border); border-radius: var(--radius); width: 100%;" />
      <div style="display: flex; gap: 0.5rem; width: 100%;">
        <textarea id="prompt" placeholder="Digite sua pergunta ou busca por pacientes..." rows="1" style="flex: 1;"></textarea>
        <button id="sendBtn">Enviar</button>
      </div>
    </div>
  </div>

  <script>
    // --- ELEMENTOS GLOBAIS E VARIAVEIS DE ESTADO ---

    // Referencia ao container que exibe as mensagens do chat.
    const messagesEl = document.getElementById("messages");

    // Variaveis para guardar as instancias da biblioteca Choices.js.
    // Isso permite acessar metodos da biblioteca posteriormente (ex: para obter valores).
    let choicesConvenio = null;
    let choicesProfissional = null;
    let choicesConjunto = null;

    // --- FUNCOES PRINCIPAIS ---

    /**
     * Cria e adiciona uma nova mensagem na interface do chat.
     * @param {string} text - O conteudo da mensagem a ser exibida.
     * @param {string} [who="user"] - O remetente da mensagem ('user' ou 'bot').
     */
    function createMessage(text, who = "user") {
      const div = document.createElement("div");
      div.className = `message ${who}`;

      // Se a mensagem for do bot, ela pode conter Markdown.
      if (who === "bot") {
        // Usa a biblioteca 'marked' para converter o texto de Markdown para HTML.
        div.innerHTML = marked.parse(text);
        
        // --- LOGICA PARA GERACAO DE GRAFICOS ---
        // Procura por um bloco de codigo na resposta do bot.
        const codeBlock = div.querySelector('pre code');
        if (codeBlock) {
          // Se encontrar um bloco de codigo, cria um botao para gerar o grafico.
          const plotButton = document.createElement('button');
          plotButton.innerText = 'Gerar Grafico';
          plotButton.className = 'plot-button'; 
          
          // Insere o botao logo apos o elemento <pre> que contem o codigo.
          const preParent = codeBlock.closest('pre');
          preParent.insertAdjacentElement('afterend', plotButton);

          // Adiciona um evento de clique ao botao.
          plotButton.addEventListener('click', async () => {
              const code = codeBlock.textContent || '';
              plotButton.innerText = 'Gerando...';
              plotButton.disabled = true; // Desabilita o botao durante o processamento.

              try {
                  // Envia o codigo para o endpoint '/plot' no backend.
                  const res = await fetch('/plot', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ code })
                  });
                  const data = await res.json();
                  
                  // Se a requisicao for bem-sucedida e retornar uma imagem.
                  if (res.ok && data.image_base64) {
                      const img = document.createElement('img');
                      img.src = `data:image/png;base64,${data.image_base64}`;
                      img.alt = "Grafico Gerado";
                      plotButton.insertAdjacentElement('afterend', img); // Mostra a imagem.
                      plotButton.style.display = 'none'; // Esconde o botao.
                  } else {
                      // Se houver um erro no backend.
                      const errorSpan = document.createElement('span');
                      errorSpan.style.color = 'red';
                      errorSpan.innerText = `Erro: ${data.error || 'Nao foi possivel gerar o grafico.'}`;
                      plotButton.insertAdjacentElement('afterend', errorSpan);
                      plotButton.innerText = 'Tentar Novamente';
                      plotButton.disabled = false; // Reabilita o botao.
                  }
              } catch (error) {
                  // Se houver um erro de rede.
                  plotButton.innerText = 'Erro de Conexao';
              }
          });
        }
      } else {
        // Se a mensagem for do usuario, apenas insere o texto puro.
        const span = document.createElement("span");
        span.innerText = text;
        div.appendChild(span);
      }
      
      // Adiciona a mensagem criada ao container de mensagens.
      messagesEl.appendChild(div);
      // Rola a visualizacao para a mensagem mais recente.
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    /**
     * Envia os dados de filtro para o backend e exibe a resposta.
     * @param {object} payload - Objeto com os filtros a serem aplicados.
     */
    async function executarFiltro(payload) {
        // Mostra uma mensagem de carregamento.
        const loadingDiv = document.createElement("div");
        loadingDiv.className = "message bot-loading";
        loadingDiv.innerHTML = "<span>Filtrando...</span>";
        messagesEl.appendChild(loadingDiv);
        messagesEl.scrollTop = messagesEl.scrollHeight;

        try {
            // Faz a requisicao POST para o endpoint '/filter'.
            const res = await fetch("/filter", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload)
            });
            const data = await res.json();
            document.querySelector(".bot-loading")?.remove(); // Remove a mensagem de carregamento.
            if (res.ok) {
                createMessage(data.resposta, "bot"); // Exibe a resposta do bot.
            } else {
                createMessage(data.error || "Ocorreu um erro no servidor.", "bot");
            }
        } catch (error) {
            document.querySelector(".bot-loading")?.remove();
            createMessage("Erro ao conectar com o servidor. Verifique sua conexao.", "bot");
        }
    }

    /**
     * Processa a entrada principal do usuario, decidindo se e uma busca ou uma pergunta de IA.
     * @param {string|null} [texto=null] - Texto opcional para enviar, se nao for pego do textarea.
     */
    async function enviarPrompt(texto = null) {
        const textarea = document.getElementById("prompt");
        const patientId = document.getElementById("patientId").value.trim();
        const promptValue = texto !== null ? texto : textarea.value.trim();

        if (!promptValue) {
            alert("Por favor, digite uma busca ou uma pergunta.");
            return;
        }

        textarea.value = ""; // Limpa o campo de entrada.
        createMessage(promptValue, "user"); // Exibe a mensagem do usuario na tela.

        // Se um ID de paciente foi fornecido, a acao e uma consulta de IA.
        if (patientId) {
            const loadingDiv = document.createElement("div");
            loadingDiv.className = "message bot-loading";
            loadingDiv.innerHTML = "<span>Carregando...</span>";
            messagesEl.appendChild(loadingDiv);
            messagesEl.scrollTop = messagesEl.scrollHeight;
            try {
                // Envia o prompt e o ID do paciente para o endpoint '/prompt'.
                const res = await fetch("/prompt", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ prompt: promptValue, patient_id: patientId })
                });
                const data = await res.json();
                document.querySelector(".bot-loading")?.remove();
                if (res.ok) {
                    createMessage(data.resposta || "Nao foi possivel obter uma resposta.", "bot");
                } else {
                    createMessage(data.error || "Ocorreu um erro no servidor.", "bot");
                }
            } catch (error) {
                document.querySelector(".bot-loading")?.remove();
                createMessage("Erro ao conectar com o servidor.", "bot");
            }
        } else {
            // Se nao ha ID de paciente, a acao e uma busca por linguagem natural.
            const loadingDiv = document.createElement("div");
            loadingDiv.className = "message bot-loading";
            loadingDiv.innerHTML = "<span>Interpretando busca...</span>";
            messagesEl.appendChild(loadingDiv);
            messagesEl.scrollTop = messagesEl.scrollHeight;
            try {
                // 1. Envia a query para o endpoint '/parse-filter' para ser interpretada.
                const parseRes = await fetch("/parse-filter", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ query: promptValue })
                });
                const parsedFilters = await parseRes.json();
                document.querySelector(".bot-loading")?.remove();
                if (!parseRes.ok) {
                    throw new Error(parsedFilters.error || "Erro ao interpretar a busca.");
                }
                // 2. Com os filtros interpretados, chama a funcao para executar a busca.
                executarFiltro(parsedFilters);
            } catch (error) {
                document.querySelector(".bot-loading")?.remove();
                createMessage(`Erro: ${error.message}`, "bot");
            }
        }
    }

    /**
     * Coleta dados dos filtros estruturados e inicia a busca de pacientes.
     */
    async function filtrarPacientes() {
        const idadeMin = document.getElementById("idadeMin").value;
        const idadeMax = document.getElementById("idadeMax").value;
        
        // Obtem os valores selecionados dos campos customizados pelo Choices.js.
        const convenios = choicesConvenio ? choicesConvenio.getValue(true) : [];
        const profissionais = choicesProfissional ? choicesProfissional.getValue(true) : [];
        const conjuntos = choicesConjunto ? choicesConjunto.getValue(true) : [];

        // Validacoes basicas da interface.
        if (!idadeMin && !idadeMax && convenios.length === 0 && profissionais.length === 0 && conjuntos.length === 0) {
            alert("Por favor, preencha ao menos um filtro para realizar a busca.");
            return;
        }
        if ((idadeMin && !idadeMax) || (!idadeMin && idadeMax)) {
            alert("Para filtrar por idade, por favor, preencha tanto a idade minima quanto a maxima.");
            return;
        }

        // Cria uma mensagem para o usuario resumindo a busca que ele fez.
        let userMessageParts = [];
        if (idadeMin && idadeMax) userMessageParts.push(`idade entre ${idadeMin} e ${idadeMax} anos`);
        if (convenios.length > 0) userMessageParts.push(`convenios: ${convenios.join(", ")}`);
        if (profissionais.length > 0) userMessageParts.push(`atendidos por: ${profissionais.join(", ")}`);
        if (conjuntos.length > 0) userMessageParts.push(`conjuntos: ${conjuntos.join(", ")}`);
        
        createMessage(`Buscando pacientes com ${userMessageParts.join(", ")}.`, "user");
        
        // Chama a funcao que executa o filtro com os dados coletados.
        executarFiltro({ 
            idade_min: idadeMin, 
            idade_max: idadeMax,
            convenios: convenios,
            profissionais: profissionais,
            conjuntos: conjuntos 
        });
    }

    /**
     * Busca os dados dos filtros no backend e os popula na tela ao carregar a pagina.
     */
    async function popularFiltros() {
      // Configuracoes padrao para todos os selects do Choices.js.
      const commonChoiceOptions = {
          removeItemButton: true,
          placeholder: true,
          searchResultLimit: 10,
          noResultsText: 'Nenhum resultado encontrado',
          itemSelectText: 'Pressione para selecionar',
      };
      
      try {
        // Busca e popula os convenios.
        const resConv = await fetch('/convenios');
        const convenios = await resConv.json();
        const convenioSelect = document.getElementById('convenioFilter');
        convenios.forEach(conv => {
          const option = new Option(conv, conv);
          convenioSelect.appendChild(option);
        });
        // Inicializa o Choices.js no select de convenios.
        choicesConvenio = new Choices(convenioSelect, {
            ...commonChoiceOptions,
            placeholderValue: 'Selecione convenios',
        });
      } catch (error) { console.error("Erro ao buscar convenios:", error); }

      try {
        // Busca e popula os profissionais.
        const resProf = await fetch('/profissionais');
        const profissionais = await resProf.json();
        const profissionalSelect = document.getElementById('profissionalFilter');
        profissionais.forEach(prof => {
            const option = new Option(prof, prof);
            profissionalSelect.appendChild(option);
        });
        // Inicializa o Choices.js no select de profissionais.
        choicesProfissional = new Choices(profissionalSelect, {
            ...commonChoiceOptions,
            placeholderValue: 'Selecione medicos',
        });
      } catch (error) { console.error("Erro ao buscar profissionais:", error); }

      try {
        // Busca e popula os conjuntos.
        const resConj = await fetch('/conjuntos');
        const conjuntos = await resConj.json();
        const conjuntoSelect = document.getElementById('conjuntoFilter');
        conjuntos.forEach(conj => {
            const option = new Option(conj, conj);
            conjuntoSelect.appendChild(option);
        });
        // Inicializa o Choices.js no select de conjuntos.
        choicesConjunto = new Choices(conjuntoSelect, {
            ...commonChoiceOptions,
            placeholderValue: 'Selecione conjuntos',
        });
      } catch (error) { console.error("Erro ao buscar conjuntos:", error); }
    }


    // --- EVENT LISTENERS (OUVINTES DE EVENTOS) ---

    // Associa a funcao 'filtrarPacientes' ao clique do botao de filtro.
    document.getElementById("filterBtn").addEventListener("click", filtrarPacientes);
    
    // Associa a funcao 'enviarPrompt' ao clique do botao de envio.
    document.getElementById("sendBtn").addEventListener("click", () => enviarPrompt());
    
    // Permite que o usuario envie a mensagem pressionando 'Enter' no textarea.
    document.getElementById("prompt").addEventListener("keydown", e => {
      // A condicao !e.shiftKey permite que o usuario quebre linhas com 'Shift + Enter'.
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault(); // Evita que uma nova linha seja criada.
        enviarPrompt();
      }
    });
      
    // Quando o conteudo HTML da pagina estiver totalmente carregado, chama a funcao para popular os filtros.
    document.addEventListener('DOMContentLoaded', popularFiltros);

    // Usa delegacao de eventos para cliques em links de ID de paciente que podem ser adicionados dinamicamente.
    messagesEl.addEventListener('click', (event) => {
        // Verifica se o elemento clicado tem a classe 'patient-id-link'.
        if (event.target.classList.contains('patient-id-link')) {
            const patientId = event.target.dataset.id; // Pega o ID do atributo 'data-id'.
            const patientIdInput = document.getElementById('patientId');
            patientIdInput.value = patientId; // Coloca o ID no campo de input.
            patientIdInput.focus(); // Coloca o foco no campo para o usuario ver a mudanca.
        }
    });
</script>
</body>
</html>